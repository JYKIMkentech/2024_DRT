%% CV_lambda_from_Results.m  —  λ 교차검증 (Results.mat 기반)
% 2025‑04‑21

clear; clc; close all;

%% 1) Results 및 OCV 읽기
load('Results.mat','Results');
soc_ocv    = Results(1).OCV;
soc_values = soc_ocv(:,1);
ocv_values = soc_ocv(:,2);

%% 2) 파라미터 설정
n            = 201;                     % 분해능 파라미터
% dur은 트립 최대 길이에 맞춰 설정하거나 수동 정의
dur          = 1370;                    % [sec]
lambda_grids = logspace(-7,1,10);       % 후보 λ 그리드
num_lambdas  = numel(lambda_grids);
numCycles    = numel(Results);

%% 3) 교차검증 조합 생성
validation_combinations = nchoosek(1:numCycles,2);
num_folds              = size(validation_combinations,1);
CVE_total              = zeros(num_lambdas,1);

%% 4) λ별 교차검증 수행
for m = 1:num_lambdas
    lambda = lambda_grids(m);
    CVE = 0;

    for f = 1:num_folds
        val_cycles   = validation_combinations(f,:);
        train_cycles = setdiff(1:numCycles, val_cycles);

        W_total = [];
        y_total = [];

        % 학습 세트에서 W_aug, y_aug 결합
        for c = train_cycles
            tripIdx = 1;
            while true
                fld = sprintf('Trips_%d', tripIdx);
                if ~isfield(Results(c), fld), break; end
                T = Results(c).(fld);
                if isempty(T)
                    tripIdx = tripIdx + 1;
                    continue;
                end

                V   = T(:,1);
                I   = T(:,2);
                t   = T(:,3);
                SOC = T(:,5);
                dt  = [t(1); diff(t)];

                [~,~,~,~, W_aug, y_aug, ~] = DRT_estimation_aug(t, I, V, lambda, n, dt, dur, SOC, soc_values, ocv_values);
                W_total = [W_total; W_aug];
                y_total = [y_total; y_aug];

                tripIdx = tripIdx + 1;
            end
        end

        % γ 및 R₀ 추정
        [gamma_total, R0_total] = DRT_estimation_aug_with_Wy(W_total, y_total, lambda);

        % 검증 세트로 CVE 계산
        for c = val_cycles
            tripIdx = 1;
            while true
                fld = sprintf('Trips_%d', tripIdx);
                if ~isfield(Results(c), fld), break; end
                T = Results(c).(fld);
                if isempty(T)
                    tripIdx = tripIdx + 1;
                    continue;
                end

                V   = T(:,1);
                I   = T(:,2);
                t   = T(:,3);
                SOC = T(:,5);
                dt  = [t(1); diff(t)];

                [~,~,~,~, W_val, ~, OCV] = DRT_estimation_aug(t, I, V, lambda, n, dt, dur, SOC, soc_values, ocv_values);
                V_est = OCV + W_val * [gamma_total; R0_total];

                CVE = CVE + sum((V - V_est).^2);
                tripIdx = tripIdx + 1;
            end
        end
    end

    CVE_total(m) = CVE;
    fprintf('Lambda: %.2e, CVE: %.4f\n', lambda, CVE);
end

%% 5) 최적 λ 선택 및 플롯
[~, idx_opt]        = min(CVE_total);
optimal_lambda      = lambda_grids(idx_opt);

figure;
semilogx(lambda_grids, CVE_total, 'b-', 'LineWidth', 1.5); hold on;
semilogx(optimal_lambda, CVE_total(idx_opt), 'ro', 'MarkerSize', 10, 'LineWidth', 2);
xlabel('\lambda','FontSize',14);
ylabel('CVE','FontSize',14);
title('CVE vs \lambda','FontSize',16);
legend({'CVE', sprintf('Optimal \lambda = %.2e', optimal_lambda)}, 'Location', 'best','FontSize',12);
hold off;

%% 6) DRT_estimation_aug_with_Wy 함수 정의
function [gamma_est, R0_est] = DRT_estimation_aug_with_Wy(W_total, y_total, lambda_hat)
    % W_total: [N×(n+1)], y_total: [N×1]
    Wn = size(W_total,2) - 1;  % gamma 파라미터 개수

    % 차분 행렬 L 구성 (1차 차분)
    L = zeros(Wn-1, Wn);
    for i = 1:Wn-1
        L(i,i)   = -1;
        L(i,i+1) =  1;
    end
    % R0에 대한 정규화 제외
    L_aug = [L, zeros(Wn-1,1)];

    % 이차 최적화 문제 설정: ½ x'Hx + f'x
    H = 2*(W_total'*W_total + lambda_hat*(L_aug'*L_aug));
    f = -2*(W_total'*y_total);

    % 비음수 제약 (gamma≥0, R0≥0)
    A = -eye(Wn+1);
    b = zeros(Wn+1,1);

    opts = optimoptions('quadprog','Display','off');
    params = quadprog(H,f,A,b,[],[],[],[],[],opts);

    gamma_est = params(1:end-1);
    R0_est    = params(end);
end
